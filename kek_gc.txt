
pull
upravit kekc, aby vzal header co mam
check, jesti je obj konstata (podle adresy(
ne? spocitat size


--------------------------------------------------------------------------------
obj_kek_t bude mit pointer do obj_table


znamená to, že u kopírovanýho objektu se musí aktualizovat pointer do tabulky a přes záznam v ní se aktualizujou starý pointery

v obj_table:

  /debug
  pointer na stary objekt
  
  
  
  spusť když tak ty tvoje testy
já jsem zkoušel jenom scheme
a ten jede
teď už snad ani nebudeš dostávat neplatný čísla typů
poslední věc
pokud ten pointer vede na objekt v const. table
tak se s ním nic dělat nebude
na to si tam přidej check
konstanty nemá cenu někam kopírovat
ty tam jsou od začátku do konce
jediná výjimka je asi pole
tam teď nic nebrání v tom, aby se pole z const. table za běhu měnilo
grin emoticon
hlavně při načítání ze souboru tam na @dbg stack: vm_call_main: kek_argv
@dbg stack: push to   stack[  0] = 0x566b3f0
@dbg stack: vm_call_main: entry_cls
@dbg stack: push to   stack[  1] = 0x566f330
prvky pole volám alloc z memory.c
takže je to takovej hybrid
samotnej array zůstává v tabulce konstant
================================================================================

@dbg stack: vm_call_main: kek_argv
@dbg stack: push to   stack[  0] = 0x566b3f0

@dbg stack: vm_call_main: entry_cls
@dbg stack: push to   stack[  1] = 0x566f330

@dbg stack: bc_call: ret
@dbg stack: push to   stack[  2] = 0x566b6b0

@dbg stack: bc_call: ap
@dbg stack: push to   stack[  3] = 0x1

@dbg stack: bc_call: fp
@dbg stack: push to   stack[  4] = 0x1

@dbg stack: bc_call: stack[5 (fp_g)] is NULL

@dbg stack: bc_call: stack[6] is LOCAL

@dbg stack: bc_call: stack[7] is LOCAL

@dbg stack: bc_call: stack[8] is -1































