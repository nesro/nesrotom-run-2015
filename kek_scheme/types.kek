#include "environment.kek"

enum Tag {
	INTEGER, STRING, SYMBOL, CONS, TRUE, FALSE, NIL, VOID, B_SYNTAX, B_FUNCTION
}

class EvalError : Exception {
	var obj
	EvalError(msg, obj) {
		super(msg)
		this.obj = obj
	}
}

class scmObject {
	var tag

	scmObject(tag) {
		this.tag = tag
	}

	toString() {
		return G.tagName[tag]
	}

	print(out) {
		out.writeln(toString())
	}

	eval(env) {
		return this
	}
}

class scmInteger : scmObject {
	var val

	scmInteger(val) {
		super(Tag.INTEGER)
		this.val = val
	}

	print(out) {
		out.writeln(String.fromInt(val))
	}
}

class scmString : scmObject {
	var str

	scmString(str) {
		super(Tag.STRING)
		this.str = str
	}

	print(out) {
		out.writeln("\"" + str + "\"")
	}
}

class scmSymbol : scmObject {
	var symName
	static var symTable
	static var symCount

	static scmSymbol() {
		symTable = []
		symCount = 0
	}

	scmSymbol(symName) {
		super(Tag.SYMBOL)
		this.symName = symName
	}

	static findSym(symName) {
		var i
		for (i = 0; i < symCount; i++) {
			if (symTable[i].symName == symName) {
				return symTable[i]
			}
		}
		return nil
	}

	static addSym(sym) {
		symTable[symCount] = sym
		symCount++
		return sym
	}

	static getSym(symName) {
		var sym = findSym(symName)
		if (sym != nil) return sym
		return addSym(new scmSymbol(symName))
	}

	toString() {
		return symName
	}

	print(out) {
		out.writeln(symName)
	}

	eval(env) {
		return env.get(this)
	}
}

class scmCons : scmObject {
	var car, cdr

	scmCons(car, cdr) {
		super(Tag.CONS)
		this.car = car
		this.cdr = cdr
	}

	print(out) {
		var obj = this
		out.writeln("(")
		while (1) {
			if (obj.tag != Tag.CONS) {
				out.writeln(". ")
				obj.print(out)
				out.writeln(")")
				return
			}

			obj.car.print(out)
			obj = obj.cdr
			if (obj.tag != Tag.NIL) {
				out.writeln(" ")
			}
			else break
		}
		out.writeln(")")
	}

	eval(env) {
		var fnVal = car.eval(env)
		switch (fnVal.tag) {
		case Tag.B_SYNTAX: {
			return fnVal.eval(env, cdr)
		}
		// TODO: B_FUNCTION
		default:
			throw new EvalError("Expected function or syntax ", fnVal)
		}
	}
}

/********************************
 * Builtin syntax and functions *
 ********************************/

class scmBSyntax : scmObject {
	scmBSyntax() {
		super(Tag.B_SYNTAX)
	}
}

class scmDefine : scmBSyntax {
	scmDefine() {
		super()
	}

	eval(env, args) {
		var name, rest, restrest, value
		if (args.tag != Tag.CONS) {
			throw new EvalError("define expects 2 arguments ", args)
		}
		name = args.car
		rest = args.cdr
		if (rest.tag != Tag.CONS) {
			throw new EvalError("define expects 2 arguments ", args)
		}
		restrest = rest.cdr
		if (restrest.tag != Tag.NIL) {
			throw new EvalError("define expects 2 arguments ", args)
		}
		value = rest.car.eval(env)
		env.set(name, value)
		return G.scmVoid
	}
}

class G {
	static var scmTrue, scmFalse, scmNil, scmVoid
	static var tagName
	
	static G() {
		tagName = ["INT", "STR", "SYM", "CONS", "#t", "#f", "#nil", "", "#<syntax>", "#<function>"]
		scmTrue = new scmObject(Tag.TRUE)
		scmFalse = new scmObject(Tag.FALSE)
		scmNil = new scmObject(Tag.NIL)
		scmVoid = new scmObject(Tag.VOID)
	}
}
